C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE ______
OBJECT MODULE PLACED IN .\Objects\.obj
COMPILER INVOKED BY: D:\software\keil\C51\BIN\C51.EXE .c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\.lst) TABS(2) OBJECT(.\Objects\.obj)

line level    source

   1          /*************** 2019_05_19 *************/
   2          #include <stc15w.h>
   3          #include <intrins.h>
   4          //#include <LCD1602.h>
   5          
   6          /****************************** 用户定义宏 ***********************************/
   7          #define   LED_TYPE  0x00          //定义LED类型, 0x00--共阴, 0xff--共阳 秒
   8          #define   L1602_DATAPINS  P0    //数据端口
   9          
  10          /****************特殊功能寄存器声明****************/
  11          sfr ISP_DATA = 0xc2;   
  12          sfr ISP_ADDRH = 0xc3;     
  13          sfr ISP_ADDRL = 0xc4;   
  14          sfr ISP_CMD = 0xc5;   
  15          sfr ISP_TRIG = 0xc6;      
  16          sfr ISP_CONTR = 0xc7;
  17          
  18          /************** 预定义 **************/
  19          typedef   unsigned char u8;
  20          typedef   unsigned int  u16;
  21          typedef   unsigned long u32; 
  22          
  23          /*************  本地常量声明  **************/
  24          u8 code t_display[]={           //标准字库
  25          //   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
  26            0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
  27          //black  -     H    J  K    L    N  o   P  U     t    G    Q    r   M    y
  28            0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
  29            0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46,0x40}; //0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1
  30          u8 code asc[]={'0','1','2','3','4','5','6','7','8','9'};    //0-9的字符数组
  31          u8 code asc_1[]={"power by 2"};
  32          
  33          u8 code T_COM[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};    //位码
  34          
  35          
  36          /*************  IO口定义 **************/
  37          sbit    SDA = P1^1;
  38          sbit    SCL = P1^0;
  39          //sbit  LED7 = P1^7;
  40          //sbit  LED8 = P1^6;
  41          //sbit  LED9 = P4^7;
  42          //sbit  LED10 = P4^6;
  43          sbit  P_HC595_SER   = P4^0; //pin 14  SER   data input
  44          sbit  P_HC595_RCLK  = P5^4; //pin 12  RCLk  store (latch) clock
  45          sbit  P_HC595_SRCLK = P4^3; //pin 11  SRCLK Shift data clock
  46          //sbit  Less = P3^3;      //减按键
  47          //sbit  Plus = P3^2;      //加按键
  48          sbit  FY = P2^0;        //翻页/开始
  49          sbit  EN = P2^7;        //已更正（因2.7口有问题，现改为）
  50          sbit  RW = P2^6;
  51          sbit  RS= P2^5;
  52          //sbit  P2_3 = P2^4;
  53          sbit    R_C = P1^2;             //日光灯检测的端口
  54          //sbit    J_C = P1^3;             //节能灯检测的端口
C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 2   

  55          sbit    F_M = P1^1;             //蜂鸣器控制端口
  56          sbit    H_W = P1^3;             //红外接收器接口
  57          
  58          /*************  本地变量声明  **************/
  59          bit B_2ms;      //2ms标志位
  60          bit R_S;            //日光灯状态标志位
  61          bit J_S;            //节能灯状态标志位
  62          u8  LED_8[8];   //显示缓冲
  63          u8  sun_8=0;    //显示位索引
  64          u8  key_z;      //键值
  65          u8  Comparison;   //比较值
  66          u8  volt;     //键盘电压      
  67          u16 adc;      //adc值
  68          /************* 函数声明 ********************/
  69          void  Q0();
  70          //void  read_busy(void);
  71          
  72          /***************** 读忙子程序 **************/
  73          void read_busy(void)
  74          {
  75   1        L1602_DATAPINS = 0xff;
  76   1        RS = 0;
  77   1        RW = 1;
  78   1        EN = 1;
  79   1        while (P0 & 0x80);            //P0和10000000相与，D7位若不为0，停在此处
  80   1        EN = 0;                 //若为0跳出进入下一步；这条语句的作用就是检测D7位
  81   1      }
  82          
  83          /*******************************************************************************
  84          * 函 数 名         : L1602_Delay1ms
  85          * 函数功能       : 延时函数，延时1ms
  86          * 输    入         : c
  87          * 输    出         : 无
  88          * 说    名         : 该函数是在12MHZ晶振下，12分频单片机的延时。
  89          *******************************************************************************/
  90          
  91          void L1602_Delay1ms(u16 c)   //误差 0us
  92          {
  93   1          u8 a,b;
  94   1        for (; c>0; c--)
  95   1        {
  96   2           for (b=199;b>0;b--)
  97   2           {
  98   3              for(a=1;a>0;a--);
  99   3           }      
 100   2        }
 101   1            
 102   1      }
 103          
 104          /*******************************************************************************
 105          * 函 数 名         : LcdWriteCom
 106          * 函数功能       : 向LCD写入一个字节的命令
 107          * 输    入         : com
 108          * 输    出         : 无
 109          *******************************************************************************/
 110          
 111          void LcdWriteCom(u16 com)   //写入命令
 112          {
 113   1        EN = 0;             //使能
 114   1        RS = 0;             //选择发送命令
 115   1        
 116   1        L1602_DATAPINS = com;       //放入命令
C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 3   

 117   1        L1602_Delay1ms(1);      //等待数据稳定
 118   1        RW = 0;             //选择写入
 119   1      
 120   1        EN = 1;               //写入时序
 121   1        L1602_Delay1ms(5);        //保持时间
 122   1        EN = 0;
 123   1      }
 124          
 125          /*******************************************************************************
 126          * 函 数 名         : LcdWriteData
 127          * 函数功能       : 向LCD写入一个字节的数据
 128          * 输    入         : dat
 129          * 输    出         : 无
 130          *******************************************************************************/        
 131          void LcdWriteData(u16 dat)      //写入数据
 132          {
 133   1        EN = 0;             //使能清零
 134   1        RS = 1;             //选择输入数据
 135   1        L1602_DATAPINS = dat;       //写入数据
 136   1        L1602_Delay1ms(1);
 137   1        RW = 0;             //选择写入
 138   1      
 139   1        EN = 1;               //写入时序
 140   1        L1602_Delay1ms(5);        //保持时间
 141   1        EN = 0;
 142   1      }
 143          
 144          /*******************************************************************************
 145          * 函 数 名       : LcdInit()
 146          * 函数功能     : 初始化LCD屏
 147          * 输    入       : 无
 148          * 输    出       : 无
 149          *******************************************************************************/       
 150          void LcdInit()              //LCD初始化子程序
 151          {
 152   1        L1602_Delay1ms(15);
 153   1        LcdWriteCom(0x38);  //开显示
 154   1        L1602_Delay1ms(5);
 155   1        LcdWriteCom(0x38);  //开显示 
 156   1        L1602_Delay1ms(5);
 157   1        LcdWriteCom(0x38);  //开显示 
 158   1        L1602_Delay1ms(5);
 159   1        LcdWriteCom(0x0c);  //开显示不显示光标
 160   1        read_busy();
 161   1        LcdWriteCom(0x04);  //写一个指针加1
 162   1        read_busy();
 163   1        LcdWriteCom(0x01);  //清屏
 164   1        read_busy();
 165   1        LcdWriteCom(0x80);  //设置数据指针起点
 166   1      }
 167          
 168          /*********************读adc**********************************/
 169          void ADC_S(void)
 170          {
 171   1          ADC_CONTR = 0xEC;
 172   1          _nop_();
 173   1          _nop_();
 174   1          _nop_();
 175   1          _nop_();
 176   1          while(~ADC_CONTR & 0x10)
 177   1      //    adc = (u16)(ADC_RES & 3);
 178   1      //    adc = (adc << 8) | ADC_RESL;  
C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 4   

 179   1      //    ADC_CONTR = 0x84;
 180   1          adc = ADC_RES;
 181   1          adc = (adc << 2) | (ADC_RESL & 3);
 182   1      //    DisplayRTC();
 183   1      }
 184          
 185          ///*┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
 186          //函数：擦除某一扇区（每个扇区512字节）
 187          //入口：addr = 某一扇区首地址                          
 188          //┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈*/
 189          //void cc(u16 addr)
 190          //{       
 191          //// 打开 IAP 功能(ISP_CONTR.7)=1:允许编程改变Flash, 设置Flash操作等待时间
 192          //// 0x83(晶振<5M)   0x82(晶振<10M)   0x81(晶振<20M)   0x80(晶振<40M)
 193          //    ISP_CONTR = 0x82;  
 194          //    ISP_CMD   = 0x03;         // 用户可以对"Data Flash/EEPROM区"进行扇区擦除
 195          //    ISP_ADDRL = addr;         // ISP/IAP操作时的地址寄存器低八位，
 196          //    ISP_ADDRH = addr>>8;      // ISP/IAP操作时的地址寄存器高八位。
 197          //     EA =0;   
 198          //    ISP_TRIG = 0x5a;          // 在ISPEN(ISP_CONTR.7)=1时,对ISP_TRIG先写入46h，
 199          //    ISP_TRIG = 0xa5;          // 再写入B9h,ISP/IAP命令才会生效。
 200          //    _nop_();
 201          //    Q0();                     // 关闭ISP/IAP
 202          //  EA =1;
 203          //}
 204          ///*┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
 205          //函数：写一字节
 206          //入口：addr = 扇区单元地址 , dat = 待写入数据
 207          //┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈*/
 208          //void xcx(u16 addr,u8 dat)
 209          //{
 210          //    ISP_CONTR = 0x82;                  
 211          //    ISP_CMD   = 0x02;               // 用户可以对"Data Flash/EEPROM区"进行字节编程
 212          //    ISP_ADDRL = addr;        
 213          //    ISP_ADDRH = addr>>8;      
 214          //    ISP_DATA  = dat;              // 数据进ISP_DATA
 215          // //   EA = 0;
 216          //    ISP_TRIG = 0x5a;         
 217          //    ISP_TRIG = 0xa5;         
 218          //    _nop_();
 219          //    Q0();                                          // 关闭ISP/IAP
 220          ////    EA =1;
 221          //}
 222          ///*┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
 223          //函数：读一字节
 224          //入口：addr = 扇区单元地址
 225          //出口：dat  = 读出的数据
 226          //┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈*/
 227          //u8 dcx(u16 addr)
 228          //{   
 229          
 230          //    u8 dat;
 231          //       
 232          //    ISP_CONTR = 0x82;                  
 233          //    ISP_CMD   = 0x01;         // 用户可以对"Data Flash/EEPROM区"进行字节读
 234          //    ISP_ADDRL = addr;         
 235          //    ISP_ADDRH = addr>>8;      
 236          ////    EA = 0;
 237          //    ISP_TRIG = 0x5a;         
 238          //    ISP_TRIG = 0xa5;         
 239          //    _nop_();
 240          //    dat = ISP_DATA;           // 取出数据
C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 5   

 241          //    Q0();             // 关闭ISP/IAP  
 242          ////    EA = 1; 
 243          //    return dat;
 244          //}
 245          ///*┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
 246          //函数：关闭ISP/IAP操作
 247          //┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈*/
 248          //void Q0(void)
 249          //{
 250          //    ISP_CONTR = 0;            // 关闭IAP功能
 251          //    ISP_CMD   = 0;            // 待机模式，无ISP操作
 252          //    ISP_TRIG  = 0;            // 关闭IAP功能, 清与ISP有关的特殊功能寄存器
 253          //}
 254          
 255          /********************** 显示函数 ************************/
 256          void  DisplayRTC(void)
 257          {
 258   1      /*    LcdWriteData(asc[LED_8[0]]);
 259   1          LcdWriteData(asc[LED_8[1]]);
 260   1          LcdWriteData(asc[LED_8[2]]);
 261   1          LcdWriteData(asc[LED_8[3]]);  LcdWriteCom(0x80+0x05);   
 262   1          LcdWriteData(asc[LED_8[4]-32]); LcdWriteData('.');
 263   1          LcdWriteData(asc[LED_8[5]]);  LcdWriteCom(0x80+0x09);
 264   1          LcdWriteData(asc[LED_8[6]-32]); LcdWriteData('.');
 265   1          LcdWriteData(asc[LED_8[7]]);        */
 266   1      }
 267          
 268          ///******************* 20ms延时程序 *******************/
 269          //void Delay20ms()    //@11.0592MHz
 270          //{
 271          //  unsigned char i, j, k;
 272          
 273          //  _nop_();
 274          //  _nop_();
 275          //  i = 1;
 276          //  j = 216;
 277          //  k = 35;
 278          //  do
 279          //  {
 280          //    do
 281          //    {
 282          //      while (--k);
 283          //    } while (--j);
 284          //  } while (--i);
 285          //}
 286          
 287          /*****************200ms延时程序 *******************/
 288          void Delay200ms()   //@11.0592MHz
 289          {
 290   1        unsigned char i, j, k;
 291   1      
 292   1        _nop_();
 293   1        _nop_();
 294   1        i = 9;
 295   1        j = 104;
 296   1        k = 139;
 297   1        do
 298   1        {
 299   2          do
 300   2          {
 301   3            while (--k);
 302   3          } while (--j);
C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 6   

 303   2        } while (--i);
 304   1      }
 305          
 306          
 307          
 308          /*************** 定时器初始化 *****************/
 309          void Timer0Init(void)   //2毫秒@11.0592MHz
 310          {
 311   1        AUXR |= 0x80;   //定时器时钟1T模式
 312   1        TMOD &= 0xF0;   //设置定时器模式
 313   1        TL0 = 0x9A;   //设置定时初值
 314   1        TH0 = 0xA9;   //设置定时初值
 315   1        TF0 = 0;    //清除TF0标志
 316   1        TR0 = 1;    //定时器0开始计时
 317   1        ET0=1;
 318   1      }
 319          
 320          /********************** Timer0 2ms中断函数 ************************/
 321          void timer0 (void) interrupt 1
 322          {
 323   1      //  DisplayScan();  //2ms扫描显示
 324   1        B_2ms = 1;    //2ms标志位
 325   1      //    A_2ms = 1;
 326   1      }
 327          
 328          
 329          /************************ 主函数 **********************************/
 330          void main(void)
 331          {
 332   1        u8 B_10ms = 0;
 333   1        u8 i = 0;
 334   1        u16 B_3s = 0;
 335   1          F_M = 1;
 336   1          F0 = 0;
 337   1        P0M0 = 0;           // IO口初始化
 338   1        P0M1 = 0;
 339   1        P2M0 = 0;
 340   1        P2M1 = 0;           //设置成双向口
 341   1        
 342   1        Timer0Init();           //定时器0初始化
 343   1        EA = 1;             //总中断开关
 344   1        ET0 = 1;            //定时器0中断允许
 345   1      
 346   1        LcdInit();            //查看资料说明，不应开机立即执行lcd初始化。
 347   1        LcdWriteCom(0x80+0x40);
 348   1        P1ASF = 0x10;         //设置P1.4为模拟量输入功能
 349   1        ADC_CONTR = 0x81;       //打开A/D转换电源，设置输入通道
 350   1        for (i = 0; i < 10; i++)        //开机显示内容
 351   1        {
 352   2          LcdWriteData(asc_1[i]);     
 353   2        }
 354   1        Delay200ms();
 355   1        F_M = 0; 
 356   1        
 357   1        while(1)
 358   1        {
 359   2              
 360   2          if(B_2ms)
 361   2          {
 362   3            if (FY)
 363   3            {
 364   4              F_M = 0;
C51 COMPILER V9.57.0.0   ______                                                            06/04/2019 16:01:36 PAGE 7   

 365   4            }
 366   3            else
 367   3            {
 368   4              F_M = 1;
 369   4            }
 370   3            ADC_S();
 371   3            DisplayRTC();
 372   3            B_2ms = 0;
 373   3          }
 374   2        } 
 375   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    320    ----
   CONSTANT SIZE    =     73    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
